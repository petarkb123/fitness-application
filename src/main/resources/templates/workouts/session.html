<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_parameter" th:content="${_csrf.parameterName}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a30">
    <title>FitPower - Workout Session</title>
    <link rel="manifest" th:href="@{/manifest.json}">
    <link rel="stylesheet" th:href="@{/css/desktop/session.css}">
    <link rel="stylesheet" th:href="@{/css/mobile/session-mobile.css}" media="(max-width: 480px)">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
<div class="dashboard-container">
    
    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="/" class="logo">
                <i class="fas fa-dumbbell"></i>
                <span>FitPower</span>
            </a>
        </div>

        <nav class="sidebar-nav">
            <div class="nav-section">
                <h3 class="nav-section-title">MAIN MENU</h3>
                <ul class="nav-list">
                    <li class="nav-item">
                        <a href="/dashboard" class="nav-link">
                            <i class="fas fa-th-large"></i>
                            <span>Dashboard</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/exercises" class="nav-link">
                            <i class="fas fa-dumbbell"></i>
                            <span>Exercises</span>
                        </a>
                    </li>
                    <li class="nav-item active">
                        <a href="/workouts" class="nav-link">
                            <i class="fas fa-history"></i>
                            <span>Workouts</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/templates" class="nav-link">
                            <i class="fas fa-clipboard-list"></i>
                            <span>Templates</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/stats/weekly" class="nav-link">
                            <i class="fas fa-chart-line"></i>
                            <span>Statistics</span>
                        </a>
                    </li>
                </ul>
            </div>

            <div class="nav-section">
                <h3 class="nav-section-title">ACCOUNT</h3>
                <ul class="nav-list">
                    <li class="nav-item">
                        <a href="/settings" class="nav-link">
                            <i class="fas fa-cog"></i>
                            <span>Settings</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <form th:action="@{/logout}" method="post" style="display:inline;">
                            <button type="submit" class="nav-link" style="background:none; border:none; width:100%; text-align:left;">
                                <i class="fas fa-sign-out-alt"></i>
                                <span>Logout</span>
                            </button>
                            <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
                        </form>
                    </li>
                </ul>
            </div>
        </nav>
    </aside>

    
    <main class="main-content">
        
        <header class="top-header">
            <div class="header-left">
                <!-- Mobile only: User profile above title -->
                <div class="user-profile mobile-profile">
                    <div class="profile-avatar avatar-preview">
                        <img th:if="${navAvatar}" th:src="${navAvatar}" alt="Profile Picture" class="avatar-image">
                        <div class="avatar-placeholder" th:unless="${navAvatar}" style="display:flex;">
                            <i class="fas fa-user"></i>
                        </div>
                    </div>
                    <div class="profile-info">
                        <span class="profile-name" th:text="${username}">User</span>
                    </div>
                </div>
                <h1 class="page-title">Workout Session</h1>
            </div>
            <div class="header-right">
                <!-- Desktop only: User profile in top right (original) -->
                <div class="user-profile desktop-profile">
                    <div class="profile-avatar avatar-preview">
                        <img th:if="${navAvatar}" th:src="${navAvatar}" alt="Profile Picture" class="avatar-image">
                        <div class="avatar-placeholder" th:unless="${navAvatar}" style="display:flex;">
                            <i class="fas fa-user"></i>
                        </div>
                    </div>
                    <div class="profile-info">
                        <span class="profile-name" th:text="${username}">User</span>
                    </div>
                </div>
                <!-- Mobile only: Settings and Logout buttons -->
                <div class="header-actions">
                    <a href="/settings" class="header-btn">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </a>
                    <form th:action="@{/logout}" method="post" style="display:inline; margin:0;">
                        <button type="submit" class="header-btn">
                            <i class="fas fa-sign-out-alt"></i>
                            <span>Logout</span>
                        </button>
                        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
                    </form>
                </div>
            </div>
        </header>

        
        <div class="dashboard-content">
            
            <div class="page-header">
                <div class="page-title-section">
                    <h1 class="page-title">
                        <i class="fas fa-dumbbell"></i>
                        Workout Session
                    </h1>
                    <p class="page-subtitle">Log your sets and track your progress</p>
                    <div id="sessionTimer" style="margin-top:6px; color:#b8bdfd; font-weight:600; display:flex; flex-direction:row; align-items:center; flex-wrap:wrap; gap:8px;">
                        <i class="fas fa-clock"></i>
                        <span id="timerText">00:00:00</span>
                        <!-- Edit mode timer controls -->
                        <button id="timerEditBtn" onclick="showTimerEditInputs()" style="display:none; width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(102,126,234,0.3); border:1px solid rgba(102,126,234,0.5); border-radius:6px; color:#fff; cursor:pointer; font-size:0.8rem;">
                            <i class="fas fa-edit"></i>
                        </button>
                        <!-- Inline edit inputs (hidden by default) -->
                        <div id="timerEditInputs" style="display:none; margin-top:6px; flex-direction:row; align-items:center; gap:3px;">
                            <input type="number" id="timerHours" min="0" max="23" placeholder="H" style="width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#fff; text-align:center; font-size:0.8rem;">
                            <span style="color:#b8bdfd; font-size:0.9rem;">:</span>
                            <input type="number" id="timerMinutes" min="0" max="59" placeholder="M" style="width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#fff; text-align:center; font-size:0.8rem;">
                            <span style="color:#b8bdfd; font-size:0.9rem;">:</span>
                            <input type="number" id="timerSeconds" min="0" max="59" placeholder="S" style="width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#fff; text-align:center; font-size:0.8rem;">
                            <button onclick="saveTimerEdit()" style="width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(34,197,94,0.8); border:1px solid rgba(34,197,94,1); border-radius:6px; color:#fff; cursor:pointer; font-size:0.8rem;">
                                <i class="fas fa-check"></i>
                            </button>
                            <button onclick="cancelTimerEdit()" style="width:50px; min-height:32px; padding:0.3rem 0.25rem; background:rgba(239,68,68,0.8); border:1px solid rgba(239,68,68,1); border-radius:6px; color:#fff; cursor:pointer; font-size:0.8rem;">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="page-actions">
                    <button class="btn btn-success" onclick="finishWorkout()">
                        <i class="fas fa-check"></i>
                        <span th:text="${isEditMode} ? 'Save Changes' : 'Finish Workout'">Finish Workout</span>
                    </button>
                </div>
            </div>

            
            <div class="workout-session">
                
                <!-- Error message display -->
                <div class="error-message" id="workoutErrorMessage" style="display: none;">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span id="errorMessageText">An error occurred</span>
                </div>

                <!-- Success message display -->
                <div class="success-message" id="workoutSuccessMessage" style="display: none;">
                    <i class="fas fa-check-circle"></i>
                    <span id="successMessageText">Success!</span>
                </div>
                
                <div class="add-exercise-section">
                    <button class="btn btn-primary action-btn" onclick="finishWorkout()" th:attr="title=${isEditMode} ? 'Save changes' : 'Finish and save workout'">
                        <i class="fas fa-check"></i>
                        <span th:text="${isEditMode} ? 'Save Changes' : 'Finish Workout'">Finish Workout</span>
                    </button>
                    <button class="btn btn-primary action-btn" onclick="openAddExerciseModal()">
                        <i class="fas fa-plus"></i>
                        Add Exercise
                    </button>
                    <button class="btn btn-primary action-btn" onclick="createSuperset()" title="Merge 2 selected exercises into superset">
                        <i class="fas fa-link"></i>
                        Create Superset
                    </button>
                </div>

                
                <div class="exercises-list" id="exercisesList">
                    
                </div>

                
                <div class="empty-workout" id="emptyWorkout">
                    <div class="empty-icon">
                        <i class="fas fa-dumbbell"></i>
                    </div>
                    <h3>No exercises added yet</h3>
                    <p>Start by adding your first exercise to begin your workout!</p>
                    <button class="btn btn-primary" onclick="openAddExerciseModal()">
                        <i class="fas fa-plus"></i>
                        Add Your First Exercise
                    </button>
                </div>
            </div>
        </div>
    </main>
</div>

<div id="addExerciseModal" class="modal-overlay" style="display: none;">
    <div class="modal-container">
        <div class="modal-header">
            <h2 class="modal-title">Add Exercise</h2>
            <button class="modal-close" onclick="closeAddExerciseModal()">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <div class="modal-content">
            <div class="form-group">
                <label class="form-label">Select Exercise</label>
                <select id="exerciseSelect" class="form-select">
                    <option value="">Choose an exercise...</option>
                    <optgroup label="My exercises" th:if="${not #lists.isEmpty(exercises)}">
                        <option th:each="exercise : ${exercises}"
                                th:if="${!exercise.builtIn}"
                                th:value="${exercise.id}"
                                th:text="${exercise.name}"></option>
                    </optgroup>
                    <optgroup label="Built-in" th:if="${not #lists.isEmpty(exercises)}">
                        <option th:each="exercise : ${exercises}"
                                th:if="${exercise.builtIn}"
                                th:value="${exercise.id}"
                                th:text="${exercise.name}"></option>
                    </optgroup>
                </select>
            </div>
        </div>

        <div class="modal-actions">
            <button class="btn btn-outline" onclick="closeAddExerciseModal()">Cancel</button>
            <button class="btn btn-primary" onclick="addExerciseToWorkout()">Add Exercise</button>
        </div>
    </div>
</div>

<script th:inline="javascript">
    let exerciseCounter = 0;

    // Server data: usually [{id,name,muscleGroup|primaryMuscle,ownerUserId|builtIn}]
    const exercisesRaw = /*[[${exercises}]]*/ [];

    // Session id for submit payload
    const workoutSessionId = /*[[${sessionId}]]*/ null;

    // For detecting built-ins when only ownerUserId is provided
    const SYSTEM_USER_ID = /*[[${T(project.fitnessapplication.config.SystemDefault).SYSTEM_USER_ID}]]*/ null;

    // Normalize shape + builtIn flag so grouping works everywhere
    const exercises = (exercisesRaw || []).map(ex => {
        const mg = ex.muscleGroup ?? ex.primaryMuscle ?? 'OTHER';
        const hasBuiltProp = Object.prototype.hasOwnProperty.call(ex, 'builtIn');
        const builtIn = hasBuiltProp ? !!ex.builtIn
            : String(ex.ownerUserId ?? '') === String(SYSTEM_USER_ID ?? '');
        return { ...ex, muscleGroup: mg, builtIn };
    });
    
    // Existing sets when continuing a workout
    const existingSetsRaw = /*[[${existingSets}]]*/ null;
    const existingSets = existingSetsRaw || [];
    const elapsedSeconds = /*[[${elapsedSeconds}]]*/ 0;
    const isEditMode = /*[[${isEditMode}]]*/ false;
    const workoutDurationSeconds = /*[[${workoutDurationSeconds}]]*/ 0;
    // Use temporary draft key if no sessionId yet (allows saving drafts before session is created)
    const TEMP_DRAFT_KEY = 'workoutDraft:temp';
    const getDraftKey = () => workoutSessionId ? (`workoutDraft:${workoutSessionId}`) : TEMP_DRAFT_KEY;
    const lastPerformanceData = /*[[${lastPerformanceData}]]*/ {};
    const timers = {};
</script>

<script>
    // ---------- options (same logic as create/edit) ----------
    function groupByMuscle(items) {
        return items.reduce((acc, ex) => {
            const k = ex.muscleGroup || 'OTHER';
            (acc[k] ||= []).push(ex);
            return acc;
        }, {});
    }

    function optgroupsFor(prefix, arr) {
        const by = groupByMuscle(arr);
        const order = ['CHEST','BACK','LEGS','SHOULDERS','BICEPS','TRICEPS','FOREARMS','HAMSTRINGS','CALVES','CORE','OTHER'];
        return order
            .filter(k => by[k] && by[k].length)
            .map(k => {
                const opts = by[k]
                    .slice()
                    .sort((a,b) => a.name.localeCompare(b.name))
                    .map(ex => `<option value="${ex.id}">${ex.name}</option>`)
                    .join('');
                return `<optgroup label="${prefix} — ${k}">${opts}</optgroup>`;
            })
            .join('');
    }

    function optionHtml() {
        if (!exercises || exercises.length === 0) return '<option value="">No exercises</option>';

        const mine     = exercises.filter(ex => !ex.builtIn);
        const builtIns = exercises.filter(ex =>  ex.builtIn);

        let html = '<option value="">Select Exercise</option>';
        html += optgroupsFor('My exercises', mine);
        html += '<option value="" disabled>&nbsp;</option>';
        html += optgroupsFor('Built-in', builtIns);
        return html;
    }


    function populateExerciseSelect() {
        const sel = document.getElementById('exerciseSelect');
        if (sel) sel.innerHTML = optionHtml();
    }

    // ---------- modal ----------
    function openAddExerciseModal() {
        populateExerciseSelect(); // keep options fresh
        const m = document.getElementById('addExerciseModal');
        m.style.display = 'flex'; setTimeout(() => m.classList.add('show'), 10);
    }
    function closeAddExerciseModal() {
        const m = document.getElementById('addExerciseModal');
        m.classList.remove('show'); setTimeout(() => m.style.display = 'none', 300);
    }

    // ---------- add/remove exercises & sets ----------
    function addExerciseToWorkout() {
        const select = document.getElementById('exerciseSelect');
        const exerciseId = select.value;
        if (!exerciseId) { showErrorMessage('Please select an exercise'); return; }
        const exercise = exercises.find(ex => String(ex.id) === String(exerciseId));
        if (!exercise) { showErrorMessage('Exercise not found'); return; }
        addExerciseCard(exercise);
        select.value = '';
        closeAddExerciseModal();
    }

    function addExerciseCard(exercise) {
        const exercisesList = document.getElementById('exercisesList');
        const emptyWorkout = document.getElementById('emptyWorkout');
        if (emptyWorkout) emptyWorkout.style.display = 'none';

        const exerciseCard = document.createElement('div');
        exerciseCard.className = 'exercise-card';
        exerciseCard.id = `exercise-${exerciseCounter}`;
        exerciseCard.setAttribute('data-exercise-id', exercise.id);

        exerciseCard.innerHTML = `
      <div class="exercise-header">
        <input type="checkbox" class="exercise-select" title="Select for grouping">
        <div class="exercise-info">
          <h3 class="exercise-name">${exercise.name}</h3>
          <span class="exercise-muscle">${exercise.muscleGroup}</span>
        </div>
        <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
          <i class="fas fa-trash"></i>
        </button>
      </div>
      <div class="sets-container">
        <div class="sets-header">
          <span>Sets</span>
          <button class="btn btn-sm btn-outline" onclick="addSetWithExerciseId(${exerciseCounter})">
            <i class="fas fa-plus"></i> Add Set
          </button>
        </div>
        <div class="sets-list" id="sets-${exerciseCounter}"></div>
      </div>
      
      <!-- Compact Rest Timer -->
      <div class="compact-rest-timer" id="timer-${exerciseCounter}">
        <div class="timer-controls">
          <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
            <i class="fas fa-edit"></i>
          </button>
          <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">00:00</span>
          <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
        </div>
      </div>
    `;

        exercisesList.appendChild(exerciseCard);
        
        // Initialize timer for this exercise
        setTimeout(() => {
            initTimer(exerciseCounter);
        }, 100);
        
        // Auto-create sets if targetSets is provided (from template), otherwise add one default set
        const targetSets = exercise.targetSets || 1;
        for (let i = 0; i < targetSets; i++) {
            addSet(exerciseCounter, false, 0, exercise.id);
        }
        
        exerciseCounter++;
        try { saveDraft(); } catch(_) {}
    }

    function addSetWithExerciseId(exerciseIndex) {
        const exerciseCard = document.getElementById(`exercise-${exerciseIndex}`);
        const exerciseId = exerciseCard ? exerciseCard.getAttribute('data-exercise-id') : null;
        addSet(exerciseIndex, false, 0, exerciseId);
        try { saveDraft(); } catch(_) {}
    }
    
    function addSet(exerciseIndex, isDropSet = false, dropSetLevel = 0, exerciseId = null) {
        const setsList = document.getElementById(`sets-${exerciseIndex}`);
        const mainSetsCount = setsList.querySelectorAll('.set-row:not(.drop-set-row)').length;
        const setNumber = isDropSet ? mainSetsCount : mainSetsCount + 1;

        // Get hints for straight sets only
        let weightHint = '';
        let repsHint = '';
        if (!isDropSet && exerciseId && lastPerformanceData[String(exerciseId)]) {
            const lastData = lastPerformanceData[String(exerciseId)];
            const setData = lastData.sets && lastData.sets[setNumber];
            if (setData) {
                if (setData.weight) {
                    weightHint = setData.weight.toString();
                }
                if (setData.reps) {
                    repsHint = setData.reps.toString();
                }
            }
        }

        const row = document.createElement('div');
        row.className = 'set-row' + (isDropSet ? ' drop-set-row' : '');
        row.setAttribute('data-drop-level', dropSetLevel);
        
        const dropSetLabel = isDropSet ? ` <span class="drop-badge">Drop ${dropSetLevel}</span>` : '';
        
        row.innerHTML = `
      <div class="set-number">${setNumber}${dropSetLabel}</div>
      <div class="set-inputs">
        <input type="number" class="form-input hint-input" placeholder="Weight" min="0" step="0.5" data-hint="${weightHint}">
        <span class="input-label">kg</span>
        <input type="number" class="form-input hint-input" placeholder="Reps" min="1" data-hint="${repsHint}">
        <span class="input-label">reps</span>
      </div>
      <div class="set-actions">
        ${!isDropSet ? '<button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add drop set"><i class="fas fa-layer-group"></i></button>' : ''}
        <button class="btn-icon btn-remove" onclick="removeSet(this)">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    `;
        setsList.appendChild(row);
        renumberSets(exerciseIndex);
        try { saveDraft(); } catch(_) {}
        
        // Apply hints if they exist - do this after DOM is inserted
        setTimeout(() => {
            if (weightHint || repsHint) {
                const inputs = row.querySelectorAll('.hint-input');
                inputs.forEach(input => {
                    const hint = input.getAttribute('data-hint');
                    // Only apply hint if the input is empty
                    if (hint && !input.value) {
                        input.value = hint;
                        input.classList.add('hint-value');
                        input.addEventListener('focus', function() {
                            if (this.classList.contains('hint-value')) {
                                this.value = '';
                                this.classList.remove('hint-value');
                            }
                        });
                        input.addEventListener('blur', function() {
                            const hintValue = this.getAttribute('data-hint');
                            if (hintValue && !this.value) {
                                this.value = hintValue;
                                this.classList.add('hint-value');
                            }
                        });
                    }
                });
            }
        }, 0);
    }
    
    function addDropSet(btn) {
        const currentRow = btn.closest('.set-row');
        const setsList = currentRow.parentElement;
        const exerciseIndex = setsList.id.replace('sets-', '');
        const currentLevel = parseInt(currentRow.getAttribute('data-drop-level') || '0');
        
        // If this is a main set (level 0), mark it as having drops and generate groupId
        if (currentLevel === 0) {
            currentRow.setAttribute('data-has-drops', 'true');
            if (!currentRow.getAttribute('data-group-id')) {
            currentRow.setAttribute('data-group-id', generateUUID());
            }
        }
        
        // Find the next drop level for this set
        let nextDropLevel = currentLevel + 1;
        let insertAfter = currentRow;
        
        // Find where to insert (after all existing drop sets of this set)
        let nextSibling = currentRow.nextElementSibling;
        while (nextSibling && nextSibling.classList.contains('drop-set-row')) {
            const siblingLevel = parseInt(nextSibling.getAttribute('data-drop-level') || '0');
            if (siblingLevel <= currentLevel) break;
            nextDropLevel = Math.max(nextDropLevel, siblingLevel + 1);
            insertAfter = nextSibling;
            nextSibling = nextSibling.nextElementSibling;
        }
        
        // Find the main set this drop set belongs to
        let mainSetRow = currentRow;
        while (mainSetRow && mainSetRow.classList.contains('drop-set-row')) {
            mainSetRow = mainSetRow.previousElementSibling;
        }
        
        // Get main set number
        let mainSetNumber = null;
        if (mainSetRow && !mainSetRow.classList.contains('drop-set-row')) {
            const allMainSets = Array.from(setsList.querySelectorAll('.set-row:not(.drop-set-row)'));
            mainSetNumber = allMainSets.indexOf(mainSetRow) + 1;
        }
        
        // Get exercise ID for hint lookup
        const exerciseCard = document.getElementById(`exercise-${exerciseIndex}`);
        const exerciseId = exerciseCard ? exerciseCard.getAttribute('data-exercise-id') : null;
        
        // Get hints from last performance data for this specific drop set
        let weightHint = '';
        let repsHint = '';
        if (exerciseId && mainSetNumber && lastPerformanceData[String(exerciseId)]) {
            const lastData = lastPerformanceData[String(exerciseId)];
            const setData = lastData.sets && lastData.sets[mainSetNumber];
            // Look for the drop set at this level
            if (setData && setData.dropSets && Array.isArray(setData.dropSets)) {
                const dropSetData = setData.dropSets.find(ds => ds.groupOrder === nextDropLevel);
                if (dropSetData) {
                    if (dropSetData.weight) weightHint = dropSetData.weight.toString();
                    if (dropSetData.reps) repsHint = dropSetData.reps.toString();
                }
            }
        }
        
        const dropRow = document.createElement('div');
        dropRow.className = 'set-row drop-set-row';
        dropRow.setAttribute('data-drop-level', nextDropLevel);
        dropRow.style.marginLeft = (nextDropLevel * 20) + 'px';
        
        dropRow.innerHTML = `
      <div class="set-number"><span class="drop-badge">Drop ${nextDropLevel}</span></div>
      <div class="set-inputs">
        <input type="number" class="form-input hint-input" placeholder="Weight" min="0" step="0.5" data-hint="${weightHint}">
        <span class="input-label">kg</span>
        <input type="number" class="form-input hint-input" placeholder="Reps" min="1" data-hint="${repsHint}">
        <span class="input-label">reps</span>
      </div>
      <div class="set-actions">
        <button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add another drop"><i class="fas fa-layer-group"></i></button>
        <button class="btn-icon btn-remove" onclick="removeSet(this)">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    `;
        
        insertAfter.after(dropRow);
        renumberSets(exerciseIndex);
        try { saveDraft(); } catch(_) {}
        
        // Apply hints if they exist - do this after DOM is inserted
        setTimeout(() => {
            if (weightHint || repsHint) {
                const inputs = dropRow.querySelectorAll('.hint-input');
                inputs.forEach(input => {
                    const hint = input.getAttribute('data-hint');
                    // Only apply hint if the input is empty
                    if (hint && !input.value) {
                        input.value = hint;
                        input.classList.add('hint-value');
                        input.addEventListener('focus', function() {
                            if (this.classList.contains('hint-value')) {
                                this.value = '';
                                this.classList.remove('hint-value');
                            }
                        });
                        input.addEventListener('blur', function() {
                            const hintValue = this.getAttribute('data-hint');
                            if (hintValue && !this.value) {
                                this.value = hintValue;
                                this.classList.add('hint-value');
                            }
                        });
                    }
                });
            }
        }, 0);
    }
    
    function renumberSets(exerciseIndex) {
        const setsList = document.getElementById(`sets-${exerciseIndex}`);
        const rows = setsList.querySelectorAll('.set-row');
        let mainSetNum = 0;
        
        rows.forEach((row) => {
            const isDropSet = row.classList.contains('drop-set-row');
            if (!isDropSet) {
                mainSetNum++;
                const dropLevel = parseInt(row.getAttribute('data-drop-level') || '0');
                row.querySelector('.set-number').innerHTML = `${mainSetNum}`;
            }
        });
        try { saveDraft(); } catch(_) {}
    }

    function removeSet(btn) {
        const row = btn.closest('.set-row');
        const list = row.parentElement;
        const exerciseIndex = list.id.replace('sets-', '');
        
        // If removing a main set, also remove its drop sets
        if (!row.classList.contains('drop-set-row')) {
            let nextSibling = row.nextElementSibling;
            while (nextSibling && nextSibling.classList.contains('drop-set-row')) {
                const toRemove = nextSibling;
                nextSibling = nextSibling.nextElementSibling;
                toRemove.remove();
            }
        }
        
        row.remove();
        renumberSets(exerciseIndex);
        try { saveDraft(); } catch(_) {}
    }

    function removeExercise(exIdx) {
        const card = document.getElementById(`exercise-${exIdx}`);
        card.remove();
        const list = document.getElementById('exercisesList');
        const empty = document.getElementById('emptyWorkout');
        if (list.children.length === 0 && empty) empty.style.display = 'block';
        try { saveDraft(); } catch(_) {}
    }

    // ---------- submit ----------
    function finishWorkout() {
        const cards = document.querySelectorAll('.exercise-card');
        if (cards.length === 0) { showErrorMessage('Please add at least one exercise'); return; }

        const payload = { sessionId: workoutSessionId, exercises: [] };

        cards.forEach(card => {
            const isSuperset = card.getAttribute('data-is-superset') === 'true';
            
            if (isSuperset) {
                // Handle superset card - creates sets for BOTH exercises
                const ex1Id = card.getAttribute('data-exercise-id-1');
                const ex2Id = card.getAttribute('data-exercise-id-2');
                const groupId = generateUUID();
                
                const ex1Sets = [];
                const ex2Sets = [];
                
                card.querySelectorAll('.superset-set-row').forEach((row, setIndex) => {
                    const inputs = row.querySelectorAll('input[placeholder]');
                    // Don't save hint values
                    const isEx1WeightHint = inputs[0]?.classList.contains('hint-value');
                    const isEx1RepsHint = inputs[1]?.classList.contains('hint-value');
                    const isEx2WeightHint = inputs[2]?.classList.contains('hint-value');
                    const isEx2RepsHint = inputs[3]?.classList.contains('hint-value');
                    
                    // Skip this set if any input is a hint
                    if (isEx1WeightHint || isEx1RepsHint || isEx2WeightHint || isEx2RepsHint) {
                        return;
                    }
                    
                    const w1 = inputs[0]?.value, r1 = inputs[1]?.value;
                    const w2 = inputs[2]?.value, r2 = inputs[3]?.value;
                    
                    const weight1 = w1 ? parseFloat(w1) : 0;
                    const reps1 = r1 ? parseInt(r1, 10) : 0;
                    const weight2 = w2 ? parseFloat(w2) : 0;
                    const reps2 = r2 ? parseInt(r2, 10) : 0;
                    
                    if (weight1 > 0 && reps1 > 0) {
                        ex1Sets.push({ weight: weight1, reps: reps1, groupId, groupType: 'SUPERSET', groupOrder: 1, setNumber: setIndex + 1 });
                    }
                    if (weight2 > 0 && reps2 > 0) {
                        ex2Sets.push({ weight: weight2, reps: reps2, groupId, groupType: 'SUPERSET', groupOrder: 2, setNumber: setIndex + 1 });
                    }
                });
                
                if (ex1Sets.length > 0) payload.exercises.push({ exerciseId: ex1Id, sets: ex1Sets });
                if (ex2Sets.length > 0) payload.exercises.push({ exerciseId: ex2Id, sets: ex2Sets });
                
            } else {
                // Handle regular exercise card
                const exerciseId = card.getAttribute('data-exercise-id');
                const sets = [];
                let mainSetIndex = 0;
                
                card.querySelectorAll('.set-row').forEach(row => {
                    const isDropSet = row.classList.contains('drop-set-row');
                    const dropLevel = parseInt(row.getAttribute('data-drop-level') || '0');
                    
                    const inputs = row.querySelectorAll('input[placeholder]');
                    // Check if either input is a hint (not user-entered)
                    const isHintWeight = inputs[0]?.classList.contains('hint-value');
                    const isHintReps = inputs[1]?.classList.contains('hint-value');
                    
                    // Skip if either input is a hint
                    if (isHintWeight || isHintReps) {
                        return;
                    }
                    
                    const w = inputs[0]?.value;
                    const r = inputs[1]?.value;
                    const weight = w ? parseFloat(w) : 0;
                    const reps = r ? parseInt(r, 10) : 0;
                    
                    if (weight > 0 && reps > 0) {
                        const setData = { weight, reps };
                        
                        if (isDropSet && dropLevel > 0) {
                            // This is a drop set - find the main set it belongs to
                            let mainSetRow = null;
                            let mainSetNumber = null;
                            
                            // Look backwards to find the main set this drop set belongs to
                            let currentRow = row.previousElementSibling;
                            while (currentRow && currentRow.classList.contains('drop-set-row')) {
                                currentRow = currentRow.previousElementSibling;
                            }
                            
                            if (currentRow && !currentRow.classList.contains('drop-set-row')) {
                                mainSetRow = currentRow;
                                // Calculate main set number by counting main sets before this one
                                const allMainSets = Array.from(card.querySelectorAll('.set-row:not(.drop-set-row)'));
                                mainSetNumber = allMainSets.indexOf(mainSetRow) + 1;
                            }
                            
                            if (mainSetRow && mainSetRow.getAttribute('data-group-id')) {
                                setData.groupId = mainSetRow.getAttribute('data-group-id');
                                setData.setNumber = mainSetNumber;
                            } else {
                                setData.groupId = generateUUID(); // Fallback if no main set group
                                setData.setNumber = mainSetNumber || 1;
                            }
                            setData.groupType = 'DROP_SET';
                            setData.groupOrder = dropLevel;
                            
                        } else {
                            mainSetIndex++;
                            // This is a main set
                            if (row.getAttribute('data-has-drops') === 'true') {
                                const groupId = row.getAttribute('data-group-id') || generateUUID();
                                setData.groupId = groupId;
                                setData.groupType = 'DROP_SET';
                                setData.groupOrder = 0; // Main set has groupOrder 0
                                setData.setNumber = mainSetIndex;
                                row.setAttribute('data-group-id', groupId);
                            } else {
                                setData.setNumber = mainSetIndex;
                            }
                        }
                        
                        sets.push(setData);
                    }
                });
                
                if (exerciseId && sets.length > 0) {
                    payload.exercises.push({ exerciseId, sets });
                }
            }
        });

        if (payload.exercises.length === 0) {
            showErrorMessage('Please log at least one set before finishing the workout');
            return;
        }

        
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;
        const csrfToken  = document.querySelector('meta[name="_csrf"]').content;

        // In edit mode, get the current timer duration and send to update endpoint
        if (isEditMode && window.getTimerElapsedMs) {
            // Calculate duration from timer state
            const durationMs = window.getTimerElapsedMs();
            
            // Calculate start time as now minus duration, and finish time as now
            const now = new Date();
            const startedAt = new Date(now.getTime() - durationMs);
            const finishedAt = now;
            
            // Convert to ISO format for backend
            payload.startedAt = startedAt.toISOString();
            payload.finishedAt = finishedAt.toISOString();
        }

        const endpoint = isEditMode && workoutSessionId 
            ? `/workouts/${workoutSessionId}`
            : '/workouts/finish';
        const method = isEditMode ? 'PUT' : 'POST';

        fetch(endpoint, {
            method: method,
            headers: { 'Content-Type': 'application/json', [csrfHeader]: csrfToken },
            body: JSON.stringify(payload)
        })
            .then(r => { 
                if (r.ok) {
                    // Clear draft, rest timers, and workout timer on success (both session-specific and temp)
                    try {
                        const draftKey = getDraftKey();
                        if (draftKey) localStorage.removeItem(draftKey);
                        localStorage.removeItem(TEMP_DRAFT_KEY);
                        
                        // Clear workout timer
                        const workoutTimerKey = workoutSessionId ? (`workoutTimer:${workoutSessionId}`) : 'workoutTimer';
                        localStorage.removeItem(workoutTimerKey);
                        
                        // Clear all rest timers for this session
                        const sessionPrefix = workoutSessionId ? `restTimer:${workoutSessionId}:` : 'restTimer:temp:';
                        const tempPrefix = 'restTimer:temp:';
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key && (key.startsWith(sessionPrefix) || key.startsWith(tempPrefix))) {
                                localStorage.removeItem(key);
                            }
                        }
                    } catch(_) {}
                    window.location.href = '/workouts'; 
                } else {
                    r.text().then(() => {
                        showErrorMessage('Error finishing workout: ' + r.status + ' ' + r.statusText); 
                    });
                }
            })
            .catch(err => { 
                showErrorMessage('Error finishing workout: ' + err.message); 
            });
    }

    // ---------- superset functions ----------
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    function getSelectedCards() {
        return Array.from(document.querySelectorAll('.exercise-card'))
            .filter(card => card.querySelector('.exercise-select')?.checked);
    }

    function createSuperset() {
        const selected = getSelectedCards();
        if (selected.length !== 2) {
            showErrorMessage('Please select exactly 2 exercises to create a superset');
            return;
        }
        
        const [card1, card2] = selected;
        
        // Count sets in each exercise (excluding drop sets)
        const sets1 = card1.querySelectorAll('.set-row:not(.drop-set-row)').length;
        const sets2 = card2.querySelectorAll('.set-row:not(.drop-set-row)').length;
        
        // Validate that both exercises have the same number of sets
        if (sets1 !== sets2) {
            showErrorMessage('Both exercises must have the same number of sets to create a superset. Please match the sets of both exercises before creating a superset.');
            return;
        }
        
        if (sets1 === 0) {
            showErrorMessage('Please add at least one set to each exercise before creating a superset.');
            return;
        }
        
        const ex1Id = card1.getAttribute('data-exercise-id');
        const ex2Id = card2.getAttribute('data-exercise-id');
        const ex1Name = card1.querySelector('.exercise-name').textContent.trim();
        const ex2Name = card2.querySelector('.exercise-name').textContent.trim();
        const ex1Muscle = card1.querySelector('.exercise-muscle').textContent;
        const ex2Muscle = card2.querySelector('.exercise-muscle').textContent;
        
        // Collect set data from both exercises
        const ex1SetData = [];
        const ex2SetData = [];
        
        card1.querySelectorAll('.set-row:not(.drop-set-row)').forEach(row => {
            const inputs = row.querySelectorAll('input[placeholder]');
            // Don't copy hint values - treat them as empty
            const isWeightHint = inputs[0]?.classList.contains('hint-value');
            const isRepsHint = inputs[1]?.classList.contains('hint-value');
            ex1SetData.push({
                weight: isWeightHint ? '' : (inputs[0]?.value || ''),
                reps: isRepsHint ? '' : (inputs[1]?.value || '')
            });
        });
        
        card2.querySelectorAll('.set-row:not(.drop-set-row)').forEach(row => {
            const inputs = row.querySelectorAll('input[placeholder]');
            // Don't copy hint values - treat them as empty
            const isWeightHint = inputs[0]?.classList.contains('hint-value');
            const isRepsHint = inputs[1]?.classList.contains('hint-value');
            ex2SetData.push({
                weight: isWeightHint ? '' : (inputs[0]?.value || ''),
                reps: isRepsHint ? '' : (inputs[1]?.value || '')
            });
        });
        
        // Create merged superset card
        const exercisesList = document.getElementById('exercisesList');
        const supersetCard = document.createElement('div');
        supersetCard.className = 'exercise-card superset-card';
        supersetCard.id = `exercise-${exerciseCounter}`;
        supersetCard.setAttribute('data-is-superset', 'true');
        supersetCard.setAttribute('data-exercise-id-1', ex1Id);
        supersetCard.setAttribute('data-exercise-id-2', ex2Id);
        
        const groupId = generateUUID();
        
        supersetCard.innerHTML = `
      <div class="exercise-header">
        <div class="exercise-info">
          <h3 class="exercise-name">
            <span class="superset-badge">SUPERSET</span>
            <span class="superset-exercise-titles-desktop">${ex1Name} + ${ex2Name}</span>
          </h3>
          <div class="superset-exercise-titles-mobile">
            ${ex1Name} + ${ex2Name}
          </div>
          <span class="exercise-muscle">${ex1Muscle} / ${ex2Muscle}</span>
        </div>
        <div class="exercise-actions">
          <button class="btn-icon btn-revert" onclick="revertSuperset(${exerciseCounter}, '${ex1Id}', '${ex1Name}', '${ex1Muscle}', '${ex2Id}', '${ex2Name}', '${ex2Muscle}')" title="Revert to separate exercises">
            <i class="fas fa-undo"></i>
          </button>
          <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
      <div class="sets-container">
        <div class="sets-header">
          <span>Sets</span>
          <button class="btn btn-sm btn-outline" onclick="addSupersetSet(${exerciseCounter})">
            <i class="fas fa-plus"></i> Add Set
          </button>
        </div>
        <div class="sets-list" id="sets-${exerciseCounter}"></div>
      </div>
      
      <!-- Compact Rest Timer -->
      <div class="compact-rest-timer" id="timer-${exerciseCounter}">
        <div class="timer-controls">
          <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
            <i class="fas fa-edit"></i>
          </button>
          <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">00:00</span>
          <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
        </div>
      </div>
    `;
        
        // Insert before the first selected card
        card1.before(supersetCard);
        
        // Remove the original cards
        card1.remove();
        card2.remove();
        
        // Add superset sets with preserved data using addSupersetSet for proper hint handling
        const currentExerciseIndex = exerciseCounter;
        const setsList = document.getElementById(`sets-${currentExerciseIndex}`);
        
        for (let i = 0; i < ex1SetData.length; i++) {
            addSupersetSet(currentExerciseIndex);
            const lastRow = setsList.lastElementChild;
            if (lastRow && (ex1SetData[i].weight || ex1SetData[i].reps || ex2SetData[i].weight || ex2SetData[i].reps)) {
                const inputs = lastRow.querySelectorAll('input[placeholder]');
                // Only set values if they're not empty (hints will be applied by addSupersetSet if values are empty)
                if (inputs[0] && ex1SetData[i].weight) inputs[0].value = ex1SetData[i].weight;
                if (inputs[1] && ex1SetData[i].reps) inputs[1].value = ex1SetData[i].reps;
                if (inputs[2] && ex2SetData[i].weight) inputs[2].value = ex2SetData[i].weight;
                if (inputs[3] && ex2SetData[i].reps) inputs[3].value = ex2SetData[i].reps;
            }
        }
        
        // Initialize timer for superset
        setTimeout(() => {
            initTimer(exerciseCounter);
        }, 100);
        
        exerciseCounter++;
        try { saveDraft(); } catch(_) {}
    }
    
    function addSupersetSet(exerciseIndex) {
        const setsList = document.getElementById(`sets-${exerciseIndex}`);
        const setNumber = setsList.children.length + 1;
        const card = document.getElementById(`exercise-${exerciseIndex}`);
        const ex1Id = card.getAttribute('data-exercise-id-1');
        const ex2Id = card.getAttribute('data-exercise-id-2');
        const ex1Name = card.querySelector('.exercise-name').textContent.split('+')[0].replace('SUPERSET', '').trim();
        const ex2Name = card.querySelector('.exercise-name').textContent.split('+')[1].trim();
        
        // Get hints for both exercises
        let ex1WeightHint = '', ex1RepsHint = '', ex2WeightHint = '', ex2RepsHint = '';
        if (ex1Id && lastPerformanceData[String(ex1Id)]) {
            const lastData = lastPerformanceData[String(ex1Id)];
            const setData = lastData.sets && lastData.sets[setNumber];
            if (setData) {
                if (setData.weight) ex1WeightHint = setData.weight.toString();
                if (setData.reps) ex1RepsHint = setData.reps.toString();
            }
        }
        if (ex2Id && lastPerformanceData[String(ex2Id)]) {
            const lastData = lastPerformanceData[String(ex2Id)];
            const setData = lastData.sets && lastData.sets[setNumber];
            if (setData) {
                if (setData.weight) ex2WeightHint = setData.weight.toString();
                if (setData.reps) ex2RepsHint = setData.reps.toString();
            }
        }
        
        const row = document.createElement('div');
        row.className = 'set-row superset-set-row';
        row.innerHTML = `
        <div class="set-number">${setNumber}</div>
        <div class="set-inputs">
          <div class="exercise-input-group">
            <span class="exercise-label">${ex1Name}</span>
            <input type="number" class="form-input hint-input" placeholder="Weight" min="0" step="0.5" data-exercise="1" data-hint="${ex1WeightHint}">
            <span class="input-label">kg</span>
            <input type="number" class="form-input hint-input" placeholder="Reps" min="1" data-exercise="1" data-hint="${ex1RepsHint}">
            <span class="input-label">reps</span>
          </div>
          <div class="superset-divider">+</div>
          <div class="exercise-input-group">
            <span class="exercise-label">${ex2Name}</span>
            <input type="number" class="form-input hint-input" placeholder="Weight" min="0" step="0.5" data-exercise="2" data-hint="${ex2WeightHint}">
            <span class="input-label">kg</span>
            <input type="number" class="form-input hint-input" placeholder="Reps" min="1" data-exercise="2" data-hint="${ex2RepsHint}">
            <span class="input-label">reps</span>
          </div>
        </div>
        <div class="set-actions">
          <button class="btn-icon btn-remove" onclick="removeSet(this)">
            <i class="fas fa-trash"></i>
          </button>
        </div>
    `;
        setsList.appendChild(row);
        
        // Apply hints if they exist
        setTimeout(() => {
            const inputs = row.querySelectorAll('.hint-input');
            inputs.forEach(input => {
                const hint = input.getAttribute('data-hint');
                // Only apply hint if the input is empty
                if (hint && !input.value) {
                    input.value = hint;
                    input.classList.add('hint-value');
                    input.addEventListener('focus', function() {
                        if (this.classList.contains('hint-value')) {
                            this.value = '';
                            this.classList.remove('hint-value');
                        }
                    });
                    input.addEventListener('blur', function() {
                        const hintValue = this.getAttribute('data-hint');
                        if (hintValue && !this.value) {
                            this.value = hintValue;
                            this.classList.add('hint-value');
                        }
                    });
                }
            });
        }, 0);
        
        try { saveDraft(); } catch(_) {}
    }
    
    function revertSuperset(exerciseIndex, ex1Id, ex1Name, ex1Muscle, ex2Id, ex2Name, ex2Muscle) {
        const supersetCard = document.getElementById(`exercise-${exerciseIndex}`);
        const exercisesList = document.getElementById('exercisesList');
        
        // Collect set data from the superset
        const ex1SetData = [];
        const ex2SetData = [];
        
        supersetCard.querySelectorAll('.superset-set-row').forEach(row => {
            const inputs = row.querySelectorAll('input[placeholder]');
            // Don't copy hint values - treat them as empty
            const isEx1WeightHint = inputs[0]?.classList.contains('hint-value');
            const isEx1RepsHint = inputs[1]?.classList.contains('hint-value');
            const isEx2WeightHint = inputs[2]?.classList.contains('hint-value');
            const isEx2RepsHint = inputs[3]?.classList.contains('hint-value');
            ex1SetData.push({
                weight: isEx1WeightHint ? '' : (inputs[0]?.value || ''),
                reps: isEx1RepsHint ? '' : (inputs[1]?.value || '')
            });
            ex2SetData.push({
                weight: isEx2WeightHint ? '' : (inputs[2]?.value || ''),
                reps: isEx2RepsHint ? '' : (inputs[3]?.value || '')
            });
        });
        
        // Create two separate exercise cards
        const card1 = createEmptyExerciseCard(ex1Id, ex1Name, ex1Muscle);
        const card2 = createEmptyExerciseCard(ex2Id, ex2Name, ex2Muscle);
        
        // Insert the new cards where the superset was
        supersetCard.before(card1);
        card1.after(card2);
        
        // Get the exercise indices
        const card1Id = parseInt(card1.id.replace('exercise-', ''));
        const card2Id = parseInt(card2.id.replace('exercise-', ''));
        
        // Add sets with preserved data using addSet for proper hint handling
        const setsList1 = document.getElementById(`sets-${card1Id}`);
        ex1SetData.forEach((data) => {
            addSet(card1Id, false, 0, ex1Id);
            const lastRow = setsList1.lastElementChild;
            if (lastRow && (data.weight || data.reps)) {
                const inputs = lastRow.querySelectorAll('input');
                if (inputs[0] && data.weight) inputs[0].value = data.weight;
                if (inputs[1] && data.reps) inputs[1].value = data.reps;
            }
        });
        
        const setsList2 = document.getElementById(`sets-${card2Id}`);
        ex2SetData.forEach((data) => {
            addSet(card2Id, false, 0, ex2Id);
            const lastRow = setsList2.lastElementChild;
            if (lastRow && (data.weight || data.reps)) {
                const inputs = lastRow.querySelectorAll('input');
                if (inputs[0] && data.weight) inputs[0].value = data.weight;
                if (inputs[1] && data.reps) inputs[1].value = data.reps;
            }
        });
        
        // Initialize timers for the new cards
        setTimeout(() => {
            initTimer(card1Id);
            initTimer(card2Id);
        }, 100);
        
        // Remove the superset card
        supersetCard.remove();
        try { saveDraft(); } catch(_) {}
    }
    
    function createEmptyExerciseCard(exerciseId, exerciseName, exerciseMuscle) {
        const card = document.createElement('div');
        card.className = 'exercise-card';
        const currentIndex = exerciseCounter;
        card.id = `exercise-${currentIndex}`;
        card.setAttribute('data-exercise-id', exerciseId);
        
        card.innerHTML = `
      <div class="exercise-header">
        <input type="checkbox" class="exercise-select" title="Select for superset">
        <div class="exercise-info">
          <h3 class="exercise-name">${exerciseName}</h3>
          <span class="exercise-muscle">${exerciseMuscle}</span>
        </div>
        <button class="btn-icon btn-remove" onclick="removeExercise(${currentIndex})">
          <i class="fas fa-trash"></i>
        </button>
      </div>
      <div class="sets-container">
        <div class="sets-header">
          <span>Sets</span>
          <button class="btn btn-sm btn-outline" onclick="addSetWithExerciseId(${currentIndex})">
            <i class="fas fa-plus"></i> Add Set
          </button>
        </div>
        <div class="sets-list" id="sets-${currentIndex}"></div>
      </div>
      
      <!-- Compact Rest Timer -->
      <div class="compact-rest-timer" id="timer-${currentIndex}">
        <div class="timer-controls">
          <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${currentIndex})" title="Edit Rest Time">
            <i class="fas fa-edit"></i>
          </button>
          <span class="timer-countdown" id="timerDisplay-${currentIndex}">00:00</span>
          <button type="button" class="timer-start-btn" id="timerStart-${currentIndex}" onclick="toggleTimer(${currentIndex})">Start</button>
        </div>
      </div>
    `;
        
        exerciseCounter++;
        return card;
    }

    // Function to show error messages in the UI
    function showErrorMessage(message) {
        const errorDiv = document.getElementById('workoutErrorMessage');
        const errorText = document.getElementById('errorMessageText');
        errorText.textContent = message;
        errorDiv.style.display = 'flex';
        errorDiv.classList.add('show');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorDiv.classList.remove('show');
            setTimeout(() => errorDiv.style.display = 'none', 300);
        }, 5000);
    }

    // Function to show success messages in the UI
    function showSuccessMessage(message) {
        const successDiv = document.getElementById('workoutSuccessMessage');
        const successText = document.getElementById('successMessageText');
        successText.textContent = message;
        successDiv.style.display = 'flex';
        successDiv.classList.add('show');
        
        // Auto-hide after 3 seconds
        setTimeout(() => {
            successDiv.classList.remove('show');
            setTimeout(() => successDiv.style.display = 'none', 300);
        }, 3000);
    }

    // ---------- init ----------
    function loadTemplateExercises(templateExercises) {
        // Sort by position first to maintain order
        const sortedExercises = [...templateExercises].sort((a, b) => {
            // Use position field if available, otherwise maintain original order
            const posA = a.position !== undefined ? a.position : 0;
            const posB = b.position !== undefined ? b.position : 0;
            return posA - posB;
        });
        
        // Group exercises by groupId and type
        const supersetGroups = new Map();
        const dropSetGroups = new Map();
        const processed = new Set();
        
        // First pass: identify all groups
        for (const ex of sortedExercises) {
            if (ex.groupId && ex.groupType === 'SUPERSET') {
                if (!supersetGroups.has(ex.groupId)) {
                    supersetGroups.set(ex.groupId, []);
                }
                supersetGroups.get(ex.groupId).push(ex);
            } else if (ex.groupId && ex.groupType === 'DROP_SET') {
                if (!dropSetGroups.has(ex.groupId)) {
                    dropSetGroups.set(ex.groupId, []);
                }
                dropSetGroups.get(ex.groupId).push(ex);
            }
        }
        
        // Second pass: process in order
        for (let i = 0; i < sortedExercises.length; i++) {
            if (processed.has(i)) continue;
            const ex = sortedExercises[i];
            
            // Check if this is part of a superset
            if (ex.groupId && ex.groupType === 'SUPERSET') {
                const group = supersetGroups.get(ex.groupId);
                if (group && group.length === 2) {
                    group.sort((a, b) => (a.groupOrder || 0) - (b.groupOrder || 0));
                    const [ex1, ex2] = group;
                
                    // Create superset card directly
                    const exercisesList = document.getElementById('exercisesList');
                    const emptyState = document.getElementById('emptyWorkout');
                    if (emptyState) emptyState.style.display = 'none';
                    
                    const supersetCard = document.createElement('div');
                    supersetCard.className = 'exercise-card superset-card';
                    supersetCard.id = `exercise-${exerciseCounter}`;
                    supersetCard.setAttribute('data-is-superset', 'true');
                    supersetCard.setAttribute('data-exercise-id-1', ex1.id);
                    supersetCard.setAttribute('data-exercise-id-2', ex2.id);
                    
                    supersetCard.innerHTML = `
              <div class="exercise-header">
                <div class="exercise-info">
                  <h3 class="exercise-name">
                    <span class="superset-badge">SUPERSET</span>
                    <span class="superset-exercise-titles-desktop">${ex1.name} + ${ex2.name}</span>
                  </h3>
                  <div class="superset-exercise-titles-mobile">
                    ${ex1.name} + ${ex2.name}
                  </div>
                  <span class="exercise-muscle">${ex1.muscleGroup} / ${ex2.muscleGroup}</span>
                </div>
                <div class="exercise-actions">
                  <button class="btn-icon btn-revert" onclick="revertSuperset(${exerciseCounter}, '${ex1.id}', '${ex1.name}', '${ex1.muscleGroup}', '${ex2.id}', '${ex2.name}', '${ex2.muscleGroup}')" title="Revert to separate exercises">
                    <i class="fas fa-undo"></i>
                  </button>
                  <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              </div>
              <div class="sets-container">
                <div class="sets-header">
                  <span>Sets</span>
                  <button class="btn btn-sm btn-outline" onclick="addSupersetSet(${exerciseCounter})">
                    <i class="fas fa-plus"></i> Add Set
                  </button>
                </div>
                <div class="sets-list" id="sets-${exerciseCounter}"></div>
              </div>
              
              <!-- Compact Rest Timer -->
              <div class="compact-rest-timer" id="timer-${exerciseCounter}">
                <div class="timer-controls">
                  <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
                    <i class="fas fa-edit"></i>
                  </button>
          <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">00:00</span>
                  <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
                </div>
              </div>
            `;
                    
                    exercisesList.appendChild(supersetCard);
                    
                    // Add the target number of sets
                    const targetSets = ex1.targetSets || 3;
                    for (let i = 0; i < targetSets; i++) {
                        addSupersetSet(exerciseCounter);
                    }
                    
                    // Mark both template items as processed by finding their indices
                    for (let j = 0; j < sortedExercises.length; j++) {
                        const item = sortedExercises[j];
                        if (item.groupId === ex.groupId && item.groupType === 'SUPERSET') {
                            processed.add(j);
                        }
                    }
                    exerciseCounter++;
                }
            } 
            // Check if this is the main exercise in a drop set group
            else if (ex.groupId && ex.groupType === 'DROP_SET') {
                const group = dropSetGroups.get(ex.groupId);
                if (group && group.length > 0) {
                    // Sort by groupOrder (0 = main, 1+ = drops)
                    group.sort((a, b) => (a.groupOrder || 0) - (b.groupOrder || 0));
                    
                    // Only process if this is the main exercise (groupOrder = 0)
                    if (ex.groupOrder === 0) {
                        // Add main exercise with drop sets from template
                        const exercisesList = document.getElementById('exercisesList');
                        const emptyState = document.getElementById('emptyWorkout');
                        if (emptyState) emptyState.style.display = 'none';
                        
                        const card = document.createElement('div');
                        card.className = 'exercise-card';
                        card.id = `exercise-${exerciseCounter}`;
                        card.setAttribute('data-exercise-id', ex.id);
                        card.innerHTML = `
                  <div class="exercise-header">
                    <input type="checkbox" class="exercise-select" title="Select for superset">
                    <div class="exercise-info">
                      <h3 class="exercise-name">${ex.name}</h3>
                      <span class="exercise-muscle">${ex.muscleGroup}</span>
                    </div>
                    <div class="exercise-actions">
                      <button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add drop set">
                        <i class="fas fa-layer-group"></i>
                      </button>
                      <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </div>
                  <div class="sets-container">
                    <div class="sets-header">
                      <span>Sets</span>
                      <button class="btn btn-sm btn-outline" onclick="addSetWithExerciseId(${exerciseCounter})">
                        <i class="fas fa-plus"></i> Add Set
                      </button>
                    </div>
                    <div class="sets-list" id="sets-${exerciseCounter}"></div>
                  </div>
                  
                  <!-- Compact Rest Timer -->
                  <div class="compact-rest-timer" id="timer-${exerciseCounter}">
                    <div class="timer-controls">
                      <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
                        <i class="fas fa-edit"></i>
                      </button>
                      <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">02:00</span>
                      <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
                    </div>
                  </div>
                `;
                        
                        exercisesList.appendChild(card);
                        
                        // Add the target number of sets for the main exercise
                        const targetSets = ex.targetSets || 3;
                        for (let i = 0; i < targetSets; i++) {
                            addSet(exerciseCounter, false, 0, ex.id);
                        }
                        
                        // Add drop sets from template (groupOrder > 0)
                        const dropSets = group.filter(item => item.groupOrder > 0);
                        const setsList = card.querySelector('.sets-list');
                        const allSetRows = setsList.querySelectorAll('.set-row:not(.drop-set-row)');
                        
                        if (dropSets.length > 0) {
                            // Group drop sets by set number
                            const dropSetsBySetNumber = new Map();
                            dropSets.forEach(dropSet => {
                                // Use the actual setNumber from the drop set, or fallback to targetSets
                                const setNumber = dropSet.setNumber || ex.targetSets;
                                if (!dropSetsBySetNumber.has(setNumber)) {
                                    dropSetsBySetNumber.set(setNumber, []);
                                }
                                dropSetsBySetNumber.get(setNumber).push(dropSet);
                            });
                            
                            // Process sets from first to last to maintain correct order
                            const sortedSetNumbers = Array.from(dropSetsBySetNumber.keys()).sort((a, b) => a - b);
                            
                            sortedSetNumbers.forEach(setNumber => {
                                const sets = dropSetsBySetNumber.get(setNumber);
                                
                                // Find the main set row (setNumber is 1-based, array is 0-based)
                                const targetSetRow = allSetRows[setNumber - 1];
                                if (!targetSetRow) return;
                                
                                    // Mark the main set as having drops
                                    targetSetRow.setAttribute('data-has-drops', 'true');
                                    const groupId = ex.groupId || generateUUID();
                                    targetSetRow.setAttribute('data-group-id', groupId);
                                    
                                // Sort drop sets by groupOrder (drop level) - ascending order
                                sets.sort((a, b) => (a.groupOrder || 0) - (b.groupOrder || 0));
                                
                                // Get exercise ID for hint lookup
                                const exerciseId = ex.id;
                                
                                // Build all drop rows first, then insert them in order
                                const dropRows = [];
                                    sets.forEach((dropSet, index) => {
                                        const dropLevel = dropSet.groupOrder || (index + 1);
                                        
                                        // Get hints from last performance data for this specific drop set
                                        let weightHint = '';
                                        let repsHint = '';
                                        if (exerciseId && lastPerformanceData[String(exerciseId)]) {
                                            const lastData = lastPerformanceData[String(exerciseId)];
                                            const setData = lastData.sets && lastData.sets[setNumber];
                                            // Look for the drop set at this level
                                            if (setData && setData.dropSets && Array.isArray(setData.dropSets)) {
                                                const dropSetData = setData.dropSets.find(ds => ds.groupOrder === dropLevel);
                                                if (dropSetData) {
                                                    if (dropSetData.weight) weightHint = dropSetData.weight.toString();
                                                    if (dropSetData.reps) repsHint = dropSetData.reps.toString();
                                                }
                                            }
                                        }
                                        
                                        const dropRow = document.createElement('div');
                                        dropRow.className = 'set-row drop-set-row';
                                        dropRow.setAttribute('data-drop-level', dropLevel);
                                    dropRow.setAttribute('data-group-id', groupId);
                                        dropRow.style.marginLeft = (dropLevel * 20) + 'px';
                                        
                                        dropRow.innerHTML = `
                                  <div class="set-number"><span class="drop-badge">Drop ${dropLevel}</span></div>
                                  <div class="set-inputs">
                                    <input type="number" class="form-input hint-input" placeholder="Weight" min="0" step="0.5" data-hint="${weightHint}">
                                    <span class="input-label">kg</span>
                                    <input type="number" class="form-input hint-input" placeholder="Reps" min="1" data-hint="${repsHint}">
                                    <span class="input-label">reps</span>
                                  </div>
                                  <div class="set-actions">
                                    <button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add another drop">
                                      <i class="fas fa-layer-group"></i>
                                    </button>
                                    <button class="btn-icon btn-remove" onclick="removeSet(this)">
                                      <i class="fas fa-trash"></i>
                                    </button>
                                  </div>
                                `;
                                        
                                    dropRows.push(dropRow);
                                });
                                
                                // Insert all drop rows after the main set
                                dropRows.forEach(dropRow => {
                                    targetSetRow.insertAdjacentElement('afterend', dropRow);
                                    
                                    // Apply hints if they exist - do this after DOM is inserted
                                    setTimeout(() => {
                                        const inputs = dropRow.querySelectorAll('.hint-input');
                                        inputs.forEach(input => {
                                            const hint = input.getAttribute('data-hint');
                                            // Only apply hint if the input is empty
                                            if (hint && !input.value) {
                                                input.value = hint;
                                                input.classList.add('hint-value');
                                                input.addEventListener('focus', function() {
                                                    if (this.classList.contains('hint-value')) {
                                                        this.value = '';
                                                        this.classList.remove('hint-value');
                                                    }
                                                });
                                                input.addEventListener('blur', function() {
                                                    const hintValue = this.getAttribute('data-hint');
                                                    if (hintValue && !this.value) {
                                                        this.value = hintValue;
                                                        this.classList.add('hint-value');
                                                    }
                                                });
                                            }
                                        });
                                    }, 0);
                                });
                            });
                        }
                        
                        // Mark all items in this drop set group as processed
                        for (let j = 0; j < sortedExercises.length; j++) {
                            const item = sortedExercises[j];
                            if (item.groupId === ex.groupId && item.groupType === 'DROP_SET') {
                                processed.add(j);
                            }
                        }
                        
                        exerciseCounter++;
                    }
                }
            }
            // Regular standalone exercise
            else if (!ex.groupId) {
                addExerciseCard(ex);
                processed.add(i);
            }
        }
        
        // Initialize all timers after template load
        setTimeout(() => {
            for (let i = 1; i <= exerciseCounter; i++) {
                initTimer(i);
            }
        }, 200);
    }
    
    function loadExistingSets() {
        if (!existingSets || existingSets.length === 0) return;
        
        // Group sets by exercise and grouping info
        const byExercise = new Map();
        const supersetGroups = new Map();
        
        for (const set of existingSets) {
            const exId = set.exerciseId;
            
            // Handle supersets
            if (set.groupId && set.groupType === 'SUPERSET') {
                if (!supersetGroups.has(set.groupId)) {
                    supersetGroups.set(set.groupId, {
                        exercises: new Map(),
                        groupId: set.groupId
                    });
                }
                const group = supersetGroups.get(set.groupId);
                if (!group.exercises.has(exId)) {
                    group.exercises.set(exId, { exerciseId: exId, groupOrder: set.groupOrder, sets: [] });
                }
                group.exercises.get(exId).sets.push(set);
            } else {
                // Regular exercise or drop set
                if (!byExercise.has(exId)) {
                    byExercise.set(exId, []);
                }
                byExercise.get(exId).push(set);
            }
        }
        
        // Load supersets first
        for (const [groupId, group] of supersetGroups.entries()) {
            const exArray = Array.from(group.exercises.values()).sort((a, b) => (a.groupOrder || 0) - (b.groupOrder || 0));
            if (exArray.length === 2) {
                const [ex1Data, ex2Data] = exArray;
                const ex1 = exercises.find(e => String(e.id) === String(ex1Data.exerciseId));
                const ex2 = exercises.find(e => String(e.id) === String(ex2Data.exerciseId));
                
                if (ex1 && ex2) {
                    // Create superset card
                    const exercisesList = document.getElementById('exercisesList');
                    const emptyState = document.getElementById('emptyWorkout');
                    if (emptyState) emptyState.style.display = 'none';
                    
                    const supersetCard = document.createElement('div');
                    supersetCard.className = 'exercise-card superset-card';
                    supersetCard.id = `exercise-${exerciseCounter}`;
                    supersetCard.setAttribute('data-is-superset', 'true');
                    supersetCard.setAttribute('data-exercise-id-1', ex1.id);
                    supersetCard.setAttribute('data-exercise-id-2', ex2.id);
                    
                    supersetCard.innerHTML = `
                        <div class="exercise-header">
                            <div class="exercise-info">
                                <h3 class="exercise-name">
                                    <span class="superset-badge">SUPERSET</span>
                                    <span class="superset-exercise-titles-desktop">${ex1.name} + ${ex2.name}</span>
                                </h3>
                                <div class="superset-exercise-titles-mobile">
                                    ${ex1.name} + ${ex2.name}
                                </div>
                                <span class="exercise-muscle">${ex1.muscleGroup} / ${ex2.muscleGroup}</span>
                            </div>
                            <div class="exercise-actions">
                                <button class="btn-icon btn-revert" onclick="revertSuperset(${exerciseCounter}, '${ex1.id}', '${ex1.name}', '${ex1.muscleGroup}', '${ex2.id}', '${ex2.name}', '${ex2.muscleGroup}')" title="Revert to separate exercises">
                                    <i class="fas fa-undo"></i>
                                </button>
                                <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="sets-container">
                            <div class="sets-header">
                                <span>Sets</span>
                                <button class="btn btn-sm btn-outline" onclick="addSupersetSet(${exerciseCounter})">
                                    <i class="fas fa-plus"></i> Add Set
                                </button>
                            </div>
                            <div class="sets-list" id="sets-${exerciseCounter}"></div>
                        </div>
                        
                        <!-- Compact Rest Timer -->
                        <div class="compact-rest-timer" id="timer-${exerciseCounter}">
                          <div class="timer-controls">
                            <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
                              <i class="fas fa-edit"></i>
                            </button>
                            <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">02:00</span>
                            <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
                          </div>
                        </div>
                    `;
                    
                    exercisesList.appendChild(supersetCard);
                    
                    // Add existing sets with data
                    const setsList = supersetCard.querySelector('.sets-list');
                    const numSets = Math.max(ex1Data.sets.length, ex2Data.sets.length);
                    for (let i = 0; i < numSets; i++) {
                        const set1 = ex1Data.sets[i];
                        const set2 = ex2Data.sets[i];
                        
                        const setNumber = i + 1;
                        const row = document.createElement('div');
                        row.className = 'set-row superset-set-row';
                        row.innerHTML = `
                            <div class="set-number">${setNumber}</div>
                                <div class="set-inputs">
                                <div class="exercise-input-group">
                                    <span class="exercise-label">${ex1.name}</span>
                                    <input type="number" class="form-input" placeholder="Weight" min="0" step="0.5" data-exercise="1" value="${set1 ? set1.weight || '' : ''}">
                                    <span class="input-label">kg</span>
                                    <input type="number" class="form-input" placeholder="Reps" min="1" data-exercise="1" value="${set1 ? set1.reps || '' : ''}">
                                    <span class="input-label">reps</span>
                                </div>
                                <div class="superset-divider">+</div>
                                <div class="exercise-input-group">
                                    <span class="exercise-label">${ex2.name}</span>
                                    <input type="number" class="form-input" placeholder="Weight" min="0" step="0.5" data-exercise="2" value="${set2 ? set2.weight || '' : ''}">
                                    <span class="input-label">kg</span>
                                    <input type="number" class="form-input" placeholder="Reps" min="1" data-exercise="2" value="${set2 ? set2.reps || '' : ''}">
                                    <span class="input-label">reps</span>
                                </div>
                            </div>
                            <div class="set-actions">
                                <button class="btn-icon btn-remove" onclick="removeSet(this)">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        `;
                        setsList.appendChild(row);
                    }
                    
                    exerciseCounter++;
                }
            }
        }
        
        // Load regular exercises
        for (const [exId, sets] of byExercise.entries()) {
            const ex = exercises.find(e => String(e.id) === String(exId));
            if (!ex) continue;
            
            // Create exercise card
            const exercisesList = document.getElementById('exercisesList');
            const emptyState = document.getElementById('emptyWorkout');
            if (emptyState) emptyState.style.display = 'none';
            
            const exerciseCard = document.createElement('div');
            exerciseCard.className = 'exercise-card';
            exerciseCard.id = `exercise-${exerciseCounter}`;
            exerciseCard.setAttribute('data-exercise-id', ex.id);
            
            exerciseCard.innerHTML = `
                <div class="exercise-header">
                    <div class="exercise-select-container">
                        <input type="checkbox" class="exercise-select" onchange="updateSupersetButton()">
                    </div>
                    <div class="exercise-info">
                        <h3 class="exercise-name">${ex.name}</h3>
                        <span class="exercise-muscle">${ex.muscleGroup}</span>
                    </div>
                    <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                <div class="sets-container">
                    <div class="sets-header">
                        <span>Sets</span>
                        <button class="btn btn-sm btn-outline" onclick="addSetWithExerciseId(${exerciseCounter})">
                            <i class="fas fa-plus"></i> Add Set
                        </button>
                    </div>
                    <div class="sets-list" id="sets-${exerciseCounter}"></div>
                </div>
                
                <!-- Compact Rest Timer -->
                <div class="compact-rest-timer" id="timer-${exerciseCounter}">
                  <div class="timer-controls">
                    <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
                      <i class="fas fa-edit"></i>
                    </button>
                    <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">02:00</span>
                    <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
                  </div>
                </div>
            `;
            
            exercisesList.appendChild(exerciseCard);
            
            // Add existing sets with data
            const setsList = exerciseCard.querySelector('.sets-list');
            
            // Group sets by groupId for drop sets
            const dropSetGroups = new Map();
            
            for (const set of sets) {
                if (set.groupId && set.groupType === 'DROP_SET') {
                    if (!dropSetGroups.has(set.groupId)) {
                        dropSetGroups.set(set.groupId, []);
                    }
                    dropSetGroups.get(set.groupId).push(set);
                }
            }
            
            // Process all sets in order
            for (const set of sets) {
                // Skip if this is a drop set (groupOrder > 0) - it will be added after its main set
                if (set.groupId && set.groupType === 'DROP_SET' && set.groupOrder > 0) {
                    continue;
                }
                
                const setNumber = setsList.children.length + 1;
                const isMainSetWithDrops = set.groupId && set.groupType === 'DROP_SET' && set.groupOrder === 0;
                
                const row = document.createElement('div');
                row.className = 'set-row';
                row.setAttribute('data-drop-level', '0');
                if (isMainSetWithDrops) {
                    row.setAttribute('data-group-id', set.groupId);
                    row.setAttribute('data-has-drops', 'true');
                }
                
                row.innerHTML = `
                    <div class="set-number">${setNumber}</div>
                    <div class="set-inputs">
                        <input type="number" class="form-input" placeholder="Weight" min="0" step="0.5" value="${set.weight || ''}">
                        <span class="input-label">kg</span>
                        <input type="number" class="form-input" placeholder="Reps" min="1" value="${set.reps || ''}">
                        <span class="input-label">reps</span>
                    </div>
                    <div class="set-actions">
                        <button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add drop set"><i class="fas fa-layer-group"></i></button>
                        <button class="btn-icon btn-remove" onclick="removeSet(this)">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                setsList.appendChild(row);
                
                // Add drop sets for this main set
                if (isMainSetWithDrops && dropSetGroups.has(set.groupId)) {
                    const drops = dropSetGroups.get(set.groupId)
                        .filter(d => d.groupOrder > 0)
                        .sort((a, b) => a.groupOrder - b.groupOrder);
                    
                    for (const dropSet of drops) {
                        const dropLevel = dropSet.groupOrder;
                        const dropRow = document.createElement('div');
                        dropRow.className = 'set-row drop-set-row';
                        dropRow.setAttribute('data-drop-level', dropLevel);
                        dropRow.style.marginLeft = (dropLevel * 20) + 'px';
                        
                        dropRow.innerHTML = `
                            <div class="set-number"><span class="drop-badge">Drop ${dropLevel}</span></div>
                            <div class="set-inputs">
                                <input type="number" class="form-input" placeholder="Weight" min="0" step="0.5" value="${dropSet.weight || ''}">
                                <span class="input-label">kg</span>
                                <input type="number" class="form-input" placeholder="Reps" min="1" value="${dropSet.reps || ''}">
                                <span class="input-label">reps</span>
                            </div>
                            <div class="set-actions">
                                <button class="btn-icon btn-drop" onclick="addDropSet(this)" title="Add another drop"><i class="fas fa-layer-group"></i></button>
                                <button class="btn-icon btn-remove" onclick="removeSet(this)">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        `;
                        setsList.appendChild(dropRow);
                    }
                }
            }
            
            exerciseCounter++;
        }
        // Initialize all timers after existing sets load
        setTimeout(() => {
            for (let i = 1; i <= exerciseCounter; i++) {
                try { initTimer(i); } catch(_) {}
            }
        }, 200);
    }
    
    document.addEventListener('DOMContentLoaded', function () {
        populateExerciseSelect();
        attachAutosaveHandlers();

        // Migrate temp draft and rest timers to session-specific keys if we now have a sessionId
        if (workoutSessionId) {
            try {
                // Migrate temp draft
                const tempDraft = localStorage.getItem(TEMP_DRAFT_KEY);
                if (tempDraft) {
                    const sessionKey = `workoutDraft:${workoutSessionId}`;
                    const existingDraft = localStorage.getItem(sessionKey);
                    // Only migrate if there's no existing session draft
                    if (!existingDraft) {
                        localStorage.setItem(sessionKey, tempDraft);
                        localStorage.removeItem(TEMP_DRAFT_KEY);
                    }
                }
                
                // Migrate temp rest timers
                const tempPrefix = 'restTimer:temp:';
                const sessionPrefix = `restTimer:${workoutSessionId}:`;
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(tempPrefix)) {
                        const newKey = key.replace(tempPrefix, sessionPrefix);
                        const existingTimer = localStorage.getItem(newKey);
                        // Only migrate if there's no existing session timer
                        if (!existingTimer) {
                            localStorage.setItem(newKey, localStorage.getItem(key));
                            localStorage.removeItem(key);
                        }
                    }
                }
            } catch(_) {}
        }

        // Prefer local draft if present (keeps supersets/groups when continuing)
        try {
            if (loadDraftIfAny && loadDraftIfAny()) {
                return; // draft loaded, skip server/template
            }
        } catch (_) {}

        // If continuing and we have persisted sets, load them
        if (existingSets && existingSets.length > 0) {
            loadExistingSets();
            return; // template not needed
        }

        // If starting from a template, preload
        const templateId = new URLSearchParams(location.search).get('templateId');
        if (templateId) {
            fetch(`/workouts/templates/${templateId}/exercises`)
                .then(r => r.json())
                .then(list => loadTemplateExercises(list))
                .catch(err => console.error('Template preload failed:', err));
        }
    });

    // ---- workout length timer (timestamp-based, resilient to background) ----
    // Save timer key globally for edit functions
    const timerKey = workoutSessionId ? (`workoutTimer:${workoutSessionId}`) : 'workoutTimer';
    
    (function initWorkoutLengthTimer(){
        const el = document.getElementById('timerText');
        if (!el) return;
        
        const key = timerKey;
        function loadState(){
            try { return JSON.parse(localStorage.getItem(key) || '{}'); } catch(_) { return {}; }
        }
        function saveState(s){
            try { localStorage.setItem(key, JSON.stringify(s)); } catch(_) {}
        }

        // Initialize from server elapsedSeconds or workoutDurationSeconds (edit mode) if no prior state
        const now = Date.now();
        let state = loadState();
        if (!state.workoutStartAt) {
            // In edit mode, initialize with fixed duration; otherwise back-calc from elapsed
            if (isEditMode && workoutDurationSeconds > 0) {
                state = { workoutStartAt: now - (workoutDurationSeconds*1000), accumulatedMs: workoutDurationSeconds*1000, resumeAt: null };
            } else {
                state = { workoutStartAt: now - (elapsedSeconds*1000), accumulatedMs: 0, resumeAt: now };
            }
            saveState(state);
        } else if (state.resumeAt == null) {
            // if previously paused, keep accumulatedMs and no resumeAt
        } else {
            // running; keep resumeAt
        }

        function getElapsedMs(){
            const s = loadState();
            const running = s.resumeAt ? (Date.now() - s.resumeAt) : 0;
            return (s.accumulatedMs || 0) + running;
        }
        function render(){
            const ms = getElapsedMs();
            const totalSec = Math.floor(ms/1000);
            const h = String(Math.floor(totalSec/3600)).padStart(2,'0');
            const m = String(Math.floor((totalSec%3600)/60)).padStart(2,'0');
            const s = String(totalSec%60).padStart(2,'0');
            el.textContent = `${h}:${m}:${s}`;
        }

        // lightweight update loop only while visible
        function startVisibleLoop(){
            if (document.visibilityState === 'visible') {
                render();
            }
        }
        render();
        
        // In edit mode, show edit button and stop the timer from running
        if (isEditMode) {
            const editBtn = document.getElementById('timerEditBtn');
            if (editBtn) editBtn.style.display = 'inline-block';
            // Timer should not auto-update in edit mode
            const intervalId = setInterval(() => {
                // Only update if not in edit mode
                if (!isEditMode && document.visibilityState === 'visible') {
                    render();
                }
            }, 500);
            document.addEventListener('visibilitychange', () => {
                if (!isEditMode) render();
            });
            window.addEventListener('beforeunload', () => clearInterval(intervalId));
        } else {
            const intervalId = setInterval(startVisibleLoop, 500);
            document.addEventListener('visibilitychange', render);
            window.addEventListener('beforeunload', () => clearInterval(intervalId));
        }
        
        // Store render function globally for edit mode
        window.renderTimer = render;
        window.loadTimerState = loadState;
        window.saveTimerState = saveState;
    })();
    
    // Inline timer editing functions for edit mode
    window.showTimerEditInputs = function() {
        if (!isEditMode) return;
        
        // Parse current time
        const ms = getTimerElapsedMs();
        const totalSec = Math.floor(ms / 1000);
        const hours = Math.floor(totalSec / 3600);
        const minutes = Math.floor((totalSec % 3600) / 60);
        const seconds = totalSec % 60;
        
        // Populate inputs
        document.getElementById('timerHours').value = hours;
        document.getElementById('timerMinutes').value = minutes;
        document.getElementById('timerSeconds').value = seconds;
        
        // Show inputs and hide edit button
        document.getElementById('timerEditInputs').style.display = 'flex';
        document.getElementById('timerEditBtn').style.display = 'none';
        document.getElementById('timerText').style.display = 'none';
    };
    
    window.saveTimerEdit = function() {
        if (!isEditMode) return;
        
        const hours = parseInt(document.getElementById('timerHours').value) || 0;
        const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;
        const seconds = parseInt(document.getElementById('timerSeconds').value) || 0;
        
        // Validate inputs
        if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
            alert('Invalid time values. Hours: 0-23, Minutes: 0-59, Seconds: 0-59');
            return;
        }
        
        // Calculate total milliseconds
        const totalMs = (hours * 3600 + minutes * 60 + seconds) * 1000;
        
        // Save to state
        const s = window.loadTimerState();
        window.saveTimerState({ ...s, accumulatedMs: totalMs, workoutStartAt: s.workoutStartAt || Date.now() });
        
        // Update display
        if (window.renderTimer) window.renderTimer();
        
        // Hide inputs and show edit button
        document.getElementById('timerEditInputs').style.display = 'none';
        document.getElementById('timerEditBtn').style.display = 'inline-block';
        document.getElementById('timerText').style.display = 'inline';
    };
    
    window.cancelTimerEdit = function() {
        if (!isEditMode) return;
        
        // Hide inputs and show edit button
        document.getElementById('timerEditInputs').style.display = 'none';
        document.getElementById('timerEditBtn').style.display = 'inline-block';
        document.getElementById('timerText').style.display = 'inline';
    };
    
    // Expose getElapsedMs for finishWorkout
    window.getTimerElapsedMs = function() {
        const s = window.loadTimerState();
        const running = s.resumeAt ? (Date.now() - s.resumeAt) : 0;
        return (s.accumulatedMs || 0) + running;
    };

    // ---- autosave (localStorage) ----
    let autosaveTimer = null;
    function attachAutosaveHandlers(){
        document.addEventListener('input', function(e){
            if (!e.target.closest('.workout-session')) return;
            if (autosaveTimer) clearTimeout(autosaveTimer);
            autosaveTimer = setTimeout(saveDraft, 400);
        });
    }

    function saveDraft(){
        const draftKey = getDraftKey();
        if (!draftKey) return;
        const cards = Array.from(document.querySelectorAll('.exercise-card'));
        const draft = [];
        cards.forEach(card => {
            const isSuperset = card.getAttribute('data-is-superset') === 'true';
            if (isSuperset) {
                const ex1Id = card.getAttribute('data-exercise-id-1');
                const ex2Id = card.getAttribute('data-exercise-id-2');
                const rows = Array.from(card.querySelectorAll('.superset-set-row'));
                const sets = rows.map(row => {
                    const inputs = row.querySelectorAll('input[placeholder]');
                    // Don't save hint values to draft
                    const isEx1WeightHint = inputs[0]?.classList.contains('hint-value');
                    const isEx1RepsHint = inputs[1]?.classList.contains('hint-value');
                    const isEx2WeightHint = inputs[2]?.classList.contains('hint-value');
                    const isEx2RepsHint = inputs[3]?.classList.contains('hint-value');
                    return {
                        type: 'SUPERSET',
                        ex1: { weight: isEx1WeightHint ? '' : (inputs[0]?.value || ''), reps: isEx1RepsHint ? '' : (inputs[1]?.value || '') },
                        ex2: { weight: isEx2WeightHint ? '' : (inputs[2]?.value || ''), reps: isEx2RepsHint ? '' : (inputs[3]?.value || '') }
                    };
                });
                draft.push({ kind:'SUPERSET', ex1Id, ex2Id, sets });
            } else {
                const exerciseId = card.getAttribute('data-exercise-id');
                const rows = Array.from(card.querySelectorAll('.set-row'));
                const sets = rows.map(row => {
                    const inputs = row.querySelectorAll('input[placeholder]');
                    const isDrop = row.classList.contains('drop-set-row');
                    const dropLevel = parseInt(row.getAttribute('data-drop-level')||'0');
                    // Don't save hint values to draft
                    const isHintWeight = inputs[0]?.classList.contains('hint-value');
                    const isHintReps = inputs[1]?.classList.contains('hint-value');
                    return { type: isDrop ? 'DROP' : 'MAIN', level: dropLevel, weight: isHintWeight ? '' : (inputs[0]?.value||''), reps: isHintReps ? '' : (inputs[1]?.value||'') };
                });
                draft.push({ kind:'REGULAR', exerciseId, sets });
            }
        });
        try { localStorage.setItem(draftKey, JSON.stringify(draft)); } catch(_) {}
    }

    function loadDraftIfAny(){
        const draftKey = getDraftKey();
        if (!draftKey) return false;
        
        // Try to load from session-specific key first, then temp key
        let raw = null;
        try {
            if (workoutSessionId) {
                raw = localStorage.getItem(`workoutDraft:${workoutSessionId}`);
            }
            // If no session-specific draft, try temp draft
            if (!raw) {
                raw = localStorage.getItem(TEMP_DRAFT_KEY);
                // If we loaded temp draft and now have a session, migrate it
                if (raw && workoutSessionId) {
                    try {
                        localStorage.setItem(`workoutDraft:${workoutSessionId}`, raw);
                        localStorage.removeItem(TEMP_DRAFT_KEY);
                    } catch(_) {}
                }
            }
        } catch(_) {}
        if (!raw) return false;
        let data = null;
        try { data = JSON.parse(raw); } catch(_) { return false; }
        if (!Array.isArray(data) || data.length === 0) return false;

        const listEl = document.getElementById('exercisesList');
        const empty = document.getElementById('emptyWorkout');
        if (empty) empty.style.display = 'none';

        data.forEach(item => {
            if (item.kind === 'SUPERSET') {
                // build superset card
                const ex1 = exercises.find(e => String(e.id)===String(item.ex1Id));
                const ex2 = exercises.find(e => String(e.id)===String(item.ex2Id));
                if (!ex1 || !ex2) return;
                // create empty card via createSuperset logic shortcut
                const supersetCard = document.createElement('div');
                supersetCard.className = 'exercise-card superset-card';
                supersetCard.id = `exercise-${exerciseCounter}`;
                supersetCard.setAttribute('data-is-superset','true');
                supersetCard.setAttribute('data-exercise-id-1', ex1.id);
                supersetCard.setAttribute('data-exercise-id-2', ex2.id);
                supersetCard.innerHTML = `
                  <div class="exercise-header">
                    <div class="exercise-info">
                      <h3 class="exercise-name">
                        <span class="superset-badge">SUPERSET</span>
                        <span class="superset-exercise-titles-desktop">${ex1.name} + ${ex2.name}</span>
                      </h3>
                      <div class="superset-exercise-titles-mobile">
                        ${ex1.name} + ${ex2.name}
                      </div>
                      <span class="exercise-muscle">${ex1.muscleGroup} / ${ex2.muscleGroup}</span>
                    </div>
                    <div class="exercise-actions">
                      <button class="btn-icon btn-revert" onclick="revertSuperset(${exerciseCounter}, '${ex1.id}', '${ex1.name}', '${ex1.muscleGroup}', '${ex2.id}', '${ex2.name}', '${ex2.muscleGroup}')" title="Revert to separate exercises"><i class="fas fa-undo"></i></button>
                      <button class="btn-icon btn-remove" onclick="removeExercise(${exerciseCounter})"><i class="fas fa-trash"></i></button>
                    </div>
                  </div>
                  <div class="sets-container"><div class="sets-header"><span>Sets</span><button class="btn btn-sm btn-outline" onclick="addSupersetSet(${exerciseCounter})"><i class="fas fa-plus"></i> Add Set</button></div><div class="sets-list" id="sets-${exerciseCounter}"></div></div>
                  
                  <!-- Compact Rest Timer -->
                  <div class="compact-rest-timer" id="timer-${exerciseCounter}">
                    <div class="timer-controls">
                      <button type="button" class="timer-edit-btn" onclick="openCustomTimerModal(${exerciseCounter})" title="Edit Rest Time">
                        <i class="fas fa-edit"></i>
                      </button>
                      <span class="timer-countdown" id="timerDisplay-${exerciseCounter}">02:00</span>
                      <button type="button" class="timer-start-btn" id="timerStart-${exerciseCounter}" onclick="toggleTimer(${exerciseCounter})">Start</button>
                    </div>
                  </div>`;
                listEl.appendChild(supersetCard);
                exerciseCounter++;
                const setsList = supersetCard.querySelector('.sets-list');
                item.sets.forEach((s, idx) => {
                    addSupersetSet(exerciseCounter-1);
                    const lastRow = setsList.lastElementChild;
                    if (lastRow && (s.ex1?.weight || s.ex1?.reps || s.ex2?.weight || s.ex2?.reps)) {
                        const inputs = lastRow.querySelectorAll('input[placeholder]');
                        if (inputs[0] && s.ex1?.weight) inputs[0].value = s.ex1.weight;
                        if (inputs[1] && s.ex1?.reps) inputs[1].value = s.ex1.reps;
                        if (inputs[2] && s.ex2?.weight) inputs[2].value = s.ex2.weight;
                        if (inputs[3] && s.ex2?.reps) inputs[3].value = s.ex2.reps;
                    }
                });
            } else if (item.kind === 'REGULAR') {
                const ex = exercises.find(e => String(e.id)===String(item.exerciseId));
                if (!ex) return;
                addExerciseCard(ex);
                const idx = exerciseCounter-1;
                const setsList = document.getElementById(`sets-${idx}`);
                setsList.innerHTML = '';
                // Rebuild sets with drop structure
                item.sets.forEach(s => {
                    if (s.type === 'MAIN') {
                        addSet(idx, false, 0, item.exerciseId);
                        const last = setsList.lastElementChild;
                        const inputs = last.querySelectorAll('input');
                        inputs[0].value = s.weight || '';
                        inputs[1].value = s.reps || '';
                    } else {
                        const mainExists = setsList.querySelector('.set-row:not(.drop-set-row):last-child');
                        if (!mainExists) { addSet(idx, false, 0, item.exerciseId); }
                        const lastMain = setsList.querySelector('.set-row:not(.drop-set-row):last-child');
                        const dropBtn = lastMain.querySelector('.btn-drop');
                        if (dropBtn) { addDropSet(dropBtn); }
                        const lastRow = setsList.lastElementChild;
                        const inputs = lastRow.querySelectorAll('input');
                        inputs[0].value = s.weight || '';
                        inputs[1].value = s.reps || '';
                    }
                });
            }
        });
        // Initialize timers after draft rebuild (rehydrates any running rests)
        setTimeout(() => {
            for (let i = 1; i <= exerciseCounter; i++) {
                try { initTimer(i); } catch(_) {}
            }
        }, 200);
        return true;
    }

    // ========== Rest Timer Functionality ==========
    
    function getRestKey(exerciseIndex) {
        const card = document.getElementById(`exercise-${exerciseIndex}`);
        if (!card) return null; // card not found, no key
        
        let keyBase;
        if (card.getAttribute('data-is-superset') === 'true') {
            const a = String(card.getAttribute('data-exercise-id-1') || '');
            const b = String(card.getAttribute('data-exercise-id-2') || '');
            if (!a || !b) return null; // incomplete data
            const pair = [a, b].sort(); // normalize order to ensure stable key
            keyBase = `superset:${pair[0]}+${pair[1]}`;
        } else {
            const exId = card.getAttribute('data-exercise-id') || '';
            if (!exId) return null; // no exercise ID
            keyBase = `regular:${exId}`;
        }
        // Use temporary session prefix if no sessionId yet (like with drafts)
        const sid = workoutSessionId ? `${workoutSessionId}:` : 'temp:';
        return `restTimer:${sid}${keyBase}`;
    }
    
    function initTimer(exerciseId) {
        if (!timers[exerciseId]) {
            timers[exerciseId] = {
                interval: null,
                seconds: 0,
                initialSeconds: 0,
                isRunning: false
            };
        }
        // Rehydrate from storage if a rest was in progress/paused
        try {
            const restKey = getRestKey(exerciseId);
            if (restKey) { // only try to rehydrate if we have a stable key
                const data = JSON.parse(localStorage.getItem(restKey) || '{}');
                if (typeof data.initialSeconds === 'number' && timers[exerciseId].initialSeconds === 0) {
                    timers[exerciseId].initialSeconds = data.initialSeconds;
                }
                if (data.paused) {
                    timers[exerciseId].isRunning = false;
                    timers[exerciseId].seconds = data.remainingSeconds ?? 0;
                } else if (data.endAt) {
                    const remainingMs = Math.max(0, data.endAt - Date.now());
                    timers[exerciseId].seconds = Math.ceil(remainingMs / 1000);
                    if (timers[exerciseId].seconds > 0) {
                        // start visible update loop
                        if (timers[exerciseId].interval) clearInterval(timers[exerciseId].interval);
                        timers[exerciseId].isRunning = true;
                        const startBtn = document.getElementById(`timerStart-${exerciseId}`);
                        if (startBtn) startBtn.textContent = 'Pause';
                        timers[exerciseId].interval = setInterval(() => {
                            const d = JSON.parse(localStorage.getItem(restKey) || '{}');
                            const rem = Math.max(0, (d.endAt || 0) - Date.now());
                            timers[exerciseId].seconds = Math.ceil(rem / 1000);
                            updateTimerDisplay(exerciseId);
                            if (timers[exerciseId].seconds <= 0) timerComplete(exerciseId);
                        }, 500);
                    } else {
                        timerComplete(exerciseId);
                    }
                }
            }
        } catch(_) {}

        // Always update the display with current timer state
        updateTimerDisplay(exerciseId);
    }
    
    function setTimerValue(exerciseId, seconds) {
        if (!timers[exerciseId]) {
            timers[exerciseId] = {
                interval: null,
                seconds: seconds,
                initialSeconds: seconds,
                isRunning: false
            };
        }
        setTimer(exerciseId, seconds);
    }
    
    function setTimer(exerciseId, seconds) {
        // Initialize timer if it doesn't exist
        if (!timers[exerciseId]) {
            timers[exerciseId] = {
                interval: null,
                seconds: seconds,
                initialSeconds: seconds,
                isRunning: false
            };
        } else {
            const timer = timers[exerciseId];
            // If timer is running, pause it first to save current state
            if (timer.isRunning) {
                pauseTimer(exerciseId);
            }
            // Now update the duration
            timer.initialSeconds = seconds;
            timer.seconds = seconds;
        }
        
        updateTimerDisplay(exerciseId);
    }
    
    function toggleTimer(exerciseId) {
        const timer = timers[exerciseId];
        if (!timer) return;
        
        const startBtn = document.getElementById(`timerStart-${exerciseId}`);
        
        if (timer.isRunning) {
            pauseTimer(exerciseId);
        } else {
            startTimer(exerciseId);
        }
    }
    
    function startTimer(exerciseId) {
        const timer = timers[exerciseId];
        if (!timer) return;

        // Persist rest end time to survive background (key based on exercise ids)
        const restKey = getRestKey(exerciseId);
        if (!restKey) return; // can't get stable key, can't persist
        
        // If timer has no duration set (00:00), fall back to last initialSeconds or a sane default (120s)
        if (!timer.seconds || timer.seconds <= 0) {
            timer.seconds = (timer.initialSeconds && timer.initialSeconds > 0) ? timer.initialSeconds : 120;
            if (!timer.initialSeconds || timer.initialSeconds <= 0) timer.initialSeconds = timer.seconds;
            updateTimerDisplay(exerciseId);
        }
        const endAt = Date.now() + (timer.seconds * 1000);
        try { localStorage.setItem(restKey, JSON.stringify({ endAt, initialSeconds: timer.initialSeconds })); } catch(_) {}
        
        timer.isRunning = true;
        const startBtn = document.getElementById(`timerStart-${exerciseId}`);
        startBtn.textContent = 'Pause';
        
        // While visible, update display using timestamp math
        if (timer.interval) clearInterval(timer.interval);
        timer.interval = setInterval(() => {
            const data = JSON.parse(localStorage.getItem(restKey) || '{}');
            const remainingMs = Math.max(0, (data.endAt || 0) - Date.now());
            timer.seconds = Math.ceil(remainingMs / 1000);
            updateTimerDisplay(exerciseId);
            if (timer.seconds <= 0) {
                timerComplete(exerciseId);
            }
        }, 500);
    }
    
    function pauseTimer(exerciseId) {
        const timer = timers[exerciseId];
        if (!timer) return;
        const restKey = getRestKey(exerciseId);
        if (!restKey) { // no key to persist to, just pause locally
            if (timer.interval) { clearInterval(timer.interval); timer.interval = null; }
        timer.isRunning = false;
            const startBtn = document.getElementById(`timerStart-${exerciseId}`);
            startBtn.textContent = 'Start';
            updateTimerDisplay(exerciseId);
            return;
        }
        // Freeze remaining seconds and remove endAt
        try {
            const data = JSON.parse(localStorage.getItem(restKey) || '{}');
            const remainingMs = Math.max(0, (data.endAt || 0) - Date.now());
            timer.seconds = Math.ceil(remainingMs / 1000);
            localStorage.setItem(restKey, JSON.stringify({ paused: true, remainingSeconds: timer.seconds, initialSeconds: timer.initialSeconds }));
        } catch(_) {}

        if (timer.interval) { clearInterval(timer.interval); timer.interval = null; }
        timer.isRunning = false;
        const startBtn = document.getElementById(`timerStart-${exerciseId}`);
        startBtn.textContent = 'Start';
        updateTimerDisplay(exerciseId);
    }
    
    function updateTimerDisplay(exerciseId) {
        const timer = timers[exerciseId];
        if (!timer) return;
        
        const minutes = Math.floor(timer.seconds / 60);
        const seconds = timer.seconds % 60;
        const display = document.getElementById(`timerDisplay-${exerciseId}`);
        
        if (display) {
            display.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }
    
    function timerComplete(exerciseId) {
        const timer = timers[exerciseId];
        if (!timer) return;
        const restKey = getRestKey(exerciseId);
        if (restKey) {
            try { localStorage.removeItem(restKey); } catch(_) {}
        }
        if (timer.interval) clearInterval(timer.interval);
        timer.interval = null;
        timer.isRunning = false;
        timer.seconds = timer.initialSeconds; // Reset to the set time
        
        playTimerSound();
        
        const startBtn = document.getElementById(`timerStart-${exerciseId}`);
        startBtn.textContent = 'Start';
        
        updateTimerDisplay(exerciseId);
    }

    // Rehydrate rest timers when coming back to the app (lock screen/background)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState !== 'visible') return;
        // For each timer on screen, recompute remaining from storage
        for (let i = 1; i <= exerciseCounter; i++) {
            const timer = timers[i];
            if (!timer) continue;
            const restKey = getRestKey(i);
            try {
                const data = JSON.parse(localStorage.getItem(restKey) || '{}');
                if (data.paused) {
                    timer.isRunning = false;
                    timer.seconds = data.remainingSeconds ?? timer.seconds;
                    if (timer.interval) { clearInterval(timer.interval); timer.interval = null; }
                    updateTimerDisplay(i);
                } else if (data.endAt) {
                    const remainingMs = Math.max(0, data.endAt - Date.now());
                    timer.seconds = Math.ceil(remainingMs / 1000);
                    if (timer.seconds <= 0) {
                        timerComplete(i);
                    } else {
                        // restart visible loop
                        if (timer.interval) clearInterval(timer.interval);
                        timer.isRunning = true;
                        const startBtn = document.getElementById(`timerStart-${i}`);
                        if (startBtn) startBtn.textContent = 'Pause';
                        timer.interval = setInterval(() => {
                            const d = JSON.parse(localStorage.getItem(restKey) || '{}');
                            const rem = Math.max(0, (d.endAt || 0) - Date.now());
                            timer.seconds = Math.ceil(rem / 1000);
                            updateTimerDisplay(i);
                            if (timer.seconds <= 0) timerComplete(i);
                        }, 500);
                    }
                }
            } catch(_) {}
        }
    });
    
    function playTimerSound() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create alarm sound with alternating frequencies
            const beepCount = 10;
            const beepDuration = 0.25; // 250ms per beep
            const pauseDuration = 0.25; // 250ms pause between beeps
            
            for (let i = 0; i < beepCount; i++) {
                const startTime = audioContext.currentTime + (i * (beepDuration + pauseDuration));
                
                // Create oscillator for each beep
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // High frequency alarm tone (800Hz)
                oscillator.frequency.setValueAtTime(800, startTime);
                
                // Gain envelope for each beep
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.05);
                gainNode.gain.linearRampToValueAtTime(0.5, startTime + beepDuration - 0.05);
                gainNode.gain.linearRampToValueAtTime(0, startTime + beepDuration);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + beepDuration);
            }
        } catch (e) {
            console.error('Could not play timer sound:', e);
        }
    }
    
    let currentEditExerciseId = null;
    
    function openCustomTimerModal(exerciseId) {
        currentEditExerciseId = exerciseId;
        const modal = document.getElementById('customTimerModal');
        const currentTimer = timers[exerciseId];
        const currentMins = currentTimer ? Math.floor(currentTimer.initialSeconds / 60) : 2;
        const currentSecs = currentTimer ? currentTimer.initialSeconds % 60 : 0;
        
        document.getElementById('customMinutes').value = currentMins;
        document.getElementById('customSeconds').value = currentSecs;
        
        modal.style.display = 'flex';
    }
    
    function closeCustomTimerModal() {
        document.getElementById('customTimerModal').style.display = 'none';
        currentEditExerciseId = null;
    }
    
    function confirmCustomTimer() {
        if (currentEditExerciseId === null) return;
        
        const minutes = parseInt(document.getElementById('customMinutes').value) || 0;
        const seconds = parseInt(document.getElementById('customSeconds').value) || 0;
        const totalSeconds = minutes * 60 + seconds;
        
        if (totalSeconds > 0) {
            setTimer(currentEditExerciseId, totalSeconds);
        }
        
        closeCustomTimerModal();
    }
    
    // Initialize timers for existing exercises
    setTimeout(() => {
        if (exerciseCounter > 0) {
            for (let i = 1; i <= exerciseCounter; i++) {
                initTimer(i);
            }
        }
    }, 100);

</script>

<!-- Custom Timer Modal -->
<div id="customTimerModal" class="custom-timer-modal" style="display: none;">
    <div class="custom-timer-modal-content">
        <div class="custom-timer-modal-header">
            <h3>Set Rest Time</h3>
            <button type="button" class="close-custom-timer-modal" onclick="closeCustomTimerModal()">&times;</button>
        </div>
        <div class="custom-timer-modal-body">
            <div class="custom-timer-inputs">
                <div class="custom-timer-input-group">
                    <label>Minutes</label>
                    <input type="number" id="customMinutes" min="0" max="59" value="2">
                </div>
                <div class="custom-timer-input-group">
                    <label>Seconds</label>
                    <input type="number" id="customSeconds" min="0" max="59" value="0">
                </div>
            </div>
        </div>
        <div class="custom-timer-modal-footer">
            <button type="button" class="btn btn-outline" onclick="closeCustomTimerModal()">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="confirmCustomTimer()">Set Time</button>
        </div>
    </div>
</div>

</body>
</html>